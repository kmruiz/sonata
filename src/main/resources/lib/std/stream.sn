requires std.stream.providers._Provider
requires std.stream.providers._ProvideFromArray
requires std.stream.providers._ProvideFromFunction
requires std.stream._Filter
requires std.stream._FlatMap
requires std.stream._Map
requires std.stream._Take
requires std.stream._WaitForResult
requires std.stream._Zip
requires std.stream._ZipWithIndex
requires std.range

entity class Stream(chain: _Provider[]) implements _Provider {
    let array() = {
        self.chain.push(_WaitForResult(self.last()))
        let result = self.last().poll()
        self.close()
        result
    }

    let take(num: number) = {
        self.chain.push(_Take(self.last(), num, 0))
        self
    }

    let map(fn: (any) -> any) = {
        self.chain.push(_Map(self.last(), fn))
        self
    }

    let flatMap(fn: (any) -> Stream) = {
        self.chain.push(_FlatMap(self.last(), StreamFromArray([]), true, fn))
        self
    }

    let zip(other: Stream) = {
        self.chain.push(_Zip(self.last(), other, false))
        self
    }

    let zipWithIndex() = {
        self.chain.push(_ZipWithIndex(self.last(), 0))
        self
    }

    let filter(predicate: (any) -> boolean) = {
        self.chain.push(_Filter(self.last(), predicate))
        self
    }

    let poll() = self.last().poll()
    let close() = {
        self.chain.forEach(?.close())
        self.stop()
    }

    let last() = self.chain[self.chain.length - 1]
}

let StreamFromArray(array: any[]) = Stream([_ProvideFromArray(array, 0)])
let StreamFromFunction(fn: (any) -> any) = Stream([_ProvideFromFunction(fn)])
let StreamFromRange(from: number, to: number) = StreamFromArray(Range(from, to))

